#version 460
#extension GL_EXT_ray_tracing : enable

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba8) uniform image2D image;

struct RayPayload {
    vec3 colour;
    vec3 pos;
    vec3 normal;
    int hitType;
    vec3 radiance;
};

layout(location = 0) rayPayloadEXT RayPayload hitValue;

float noise3D(float x, float y, float z) {
    return fract(sin(x*112.9898 + y*179.233 + z*237.212) * 43758.5453);
}

vec3 sphereDistribution(float p1, float p2) {
    return vec3(1 - 2 * p1, cos(p2*2*3.14159265) * sqrt(1 - pow(1 - 2 * p1, 2)), sin(p2*2*3.14159265) * sqrt(1 - pow(1 - 2 * p1, 2)));
}

void main() {
    vec3 pos = vec3(gl_LaunchIDEXT.x / 200.0 - 5.0, 5.0 - (gl_LaunchIDEXT.y / 200.0 - 0.2), -10.0);
	float randomId = (gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * imageSize(image).x) / (float(imageSize(image).x * imageSize(image).y)) * 153.24953;
	float seed = 31.02349;// + (float) j * 13.52648f + fmod(time, 0.523f) * 3.47f;

    vec3 dir = vec3(0, -0.3, 1);
    float tmin = 0.001;
    float tmax = 1000.0;

    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, pos, tmin, dir, tmax, 0);

    vec3 radiance = hitValue.radiance;//vec3(0);
    vec3 attenuation = vec3(1, 1, 1);
    bool miss = false;
    const int pathLength = 4;
    const int repeats = 4;
    vec3 firstPos = hitValue.pos;
    vec3 firstNormal = hitValue.normal;
    vec3 firstColour = hitValue.colour;
    if (hitValue.hitType != 0) {
        for (int j = 0; j < repeats; j++) {
            hitValue.pos = firstPos;
            hitValue.normal = firstNormal;
            hitValue.radiance = vec3(0);
            hitValue.colour = firstColour;
            attenuation = vec3(1, 1, 1);
            miss = false;
            for (int i = 0; (i < pathLength) && !miss; i++) {
                vec3 hitPos = hitValue.pos;
                vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, i + j * 2 * pathLength), noise3D(randomId, seed, pathLength + i + j * 2 * pathLength));
                vec3 newDir = normalize(randomNormal + hitValue.normal);
                attenuation = attenuation * hitValue.colour;
                traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir, tmax, 0);
                radiance += hitValue.radiance * attenuation;
                if (hitValue.hitType == 0) {
                    miss = true;
                }
            }
        }
    } else {
        radiance *= repeats;
    }
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance / float(repeats), 0.0));

    /*if (hitValue.hitType == 2) {
        vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, 0), noise3D(randomId, seed, 1));
        vec3 newDir = normalize(randomNormal + hitValue.normal);
        float roughness = 0.0;
        float metalness = 0.1;
        vec3 newDir2 = normalize(roughness * newDir + reflect(dir, hitValue.normal) * (1 - roughness));
        vec3 hitPos = hitValue.pos;
        vec3 finalColour = vec3(0);
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir2, tmax, 0);
        finalColour += metalness * hitValue.colour;
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir, tmax, 0);
        finalColour += (1 - metalness) * hitValue.colour;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColour, 0.0));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(hitValue.colour, 0.0));
    }*/
}