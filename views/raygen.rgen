// glslangValidator --target-env vulkan1.3 raygen.rgen -o raygen.spv
#version 460
#extension GL_EXT_ray_tracing : enable

// todo:
// normalen umkehren, falls man die hinterseite einer fl√§che trifft
// tiefenwerte evt. nichtlinear machen, um auf sehr kurze distanzen nicht zu verpixeln und auf grossen mehr samples zu haben

layout (push_constant) uniform mypc_t {
	vec3 pos;
    float rotX, rotY;
} mypc;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba8) uniform image2D image;
layout(set = 0, binding = 3, rgba8) uniform image2D normalImage;
layout(set = 0, binding = 4, rgba8) uniform image2D depthImage;

struct RayPayload {
    vec3 colour;
    vec3 pos;
    vec3 normal;
    int hitType;
    vec3 radiance;
};

layout(location = 0) rayPayloadEXT RayPayload hitValue;

float noise3D(float x, float y, float z) {
    return fract(sin(x*112.9898 + y*179.233 + z*237.212) * 43758.5453);
}

vec3 sphereDistribution(float p1, float p2) {
    return vec3(1 - 2 * p1, cos(p2*2*3.14159265) * sqrt(1 - pow(1 - 2 * p1, 2)), sin(p2*2*3.14159265) * sqrt(1 - pow(1 - 2 * p1, 2)));
}

float rng2(int seed) {
    int a = seed * 15485863;
    return (a * a * a % 2038074743) / 2038074743.0;
}

void main() {
    int windowWidth = imageSize(image).x * 3 / 4;
    int windowHeight = imageSize(image).y;
    //vec3 pos = vec3(gl_LaunchIDEXT.x / 200.0 - 5.0, 5.0 - (gl_LaunchIDEXT.y / 200.0 - 0.2), -10.0);
    //vec3 pos = vec3(-2.0, 2.0, -10.0);
    vec3 pos = mypc.pos;
	//float randomId = (gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * imageSize(image).x) / (float(imageSize(image).x * imageSize(image).y)) * 153.24953;
	//float randomId = float((gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 9) % 82) / (float(81.0)) * 153.24953;
	float randomId = float(gl_LaunchIDEXT.x % 9 + gl_LaunchIDEXT.y % 9 * 9) / (float(81.0)) * 153.24953;
    float seed = 31.02349;// + (float) j * 13.52648f + fmod(time, 0.523f) * 3.47f;

    //vec3 pos2 = vec3(-2.0 + (gl_LaunchIDEXT.x - windowWidth / 2.0) / float(windowHeight), 2.0 - ((gl_LaunchIDEXT.y - windowHeight / 2.0) / float(windowHeight)), -9.0);
    vec3 pos2 = pos + vec3((gl_LaunchIDEXT.x - windowWidth / 2.0) / float(windowHeight), -((gl_LaunchIDEXT.y - windowHeight / 2.0) / float(windowHeight)), 1.0);
    mat3 rotX = mat3(
        cos(mypc.rotX), 0, sin(mypc.rotX),
        0, 1, 0,
        -sin(mypc.rotX), 0, cos(mypc.rotX)
    );
    mat3 rotY = mat3(
        1, 0, 0,
        0, cos(mypc.rotY), sin(mypc.rotY),
        0, -sin(mypc.rotY), cos(mypc.rotY)
    );
    vec3 dir = rotX * rotY * normalize(pos2 - pos);
    //dir = normalize(pos2 - pos);
    //vec3 dir = normalize(vec3(0, -0.3, 1));
    float tmin = 0.00001;
    float tmax = 1000.0;

    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, pos, tmin, dir, tmax, 0);

    vec3 radiance = hitValue.radiance;//vec3(0);
    vec3 attenuation = vec3(1, 1, 1);
    bool miss = false;
    const int pathLength = 4;
    const int repeats = 4;
    vec3 firstPos = hitValue.pos;
    vec3 firstNormal = hitValue.normal;
    vec3 firstColour = hitValue.colour;
    imageStore(normalImage, ivec2(gl_LaunchIDEXT.xy), vec4(firstNormal / 2.0 + vec3(0.5), 0));
    float depth = dot(dir, firstPos - pos) / 100.0;
    if (hitValue.hitType == 0)
        depth = 1000.0;
    float depth1 = (depth * 255.0 - fract(depth * 255.0)) / 255.0;
    float depth2 = (fract(depth * 255.0) * 255.0 - fract(depth * 255.0 * 255.0)) / 255.0;
    float depth3 = (fract(depth * 255.0 * 255.0));
    imageStore(depthImage, ivec2(gl_LaunchIDEXT.xy), vec4(depth1, depth2, depth3, 0));
    if (hitValue.hitType != 0) {
        for (int j = 0; j < repeats; j++) {
            hitValue.pos = firstPos;
            hitValue.normal = firstNormal;
            hitValue.radiance = vec3(0);
            hitValue.colour = firstColour;
            attenuation = vec3(1, 1, 1);
            miss = false;
            for (int i = 0; (i < pathLength) && !miss; i++) {
                vec3 hitPos = hitValue.pos;
                //vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * imageSize(image).x) + i + j * 2 * pathLength)), noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * imageSize(image).x) + pathLength + i + j * 2 * pathLength)));
                //vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 9) % 82 + i + j * 2 * pathLength)), noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 9) % 82 + pathLength + i + j * 2 * pathLength)));
                vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x % 9 + gl_LaunchIDEXT.y % 9 * 9) * 32 + i + j * 2 * pathLength)), noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x % 9 + gl_LaunchIDEXT.y % 9 * 9) * 32 + pathLength + i + j * 2 * pathLength)));
                //vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, i + j * 2 * pathLength), noise3D(randomId, seed, pathLength + i + j * 2 * pathLength));
                vec3 newDir = normalize(randomNormal + hitValue.normal);
                attenuation = attenuation * hitValue.colour;
                traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir, tmax, 0);
                radiance += hitValue.radiance * attenuation;
                if (hitValue.hitType == 0) {
                    miss = true;
                }
            }
        }
    } else {
        radiance *= repeats;
    }
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance / float(repeats), 0.0));
    //imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(noise3D(randomId, seed, rng2(int(gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * imageSize(image).x)))), 0.0));

    /*if (hitValue.hitType == 2) {
        vec3 randomNormal = sphereDistribution(noise3D(randomId, seed, 0), noise3D(randomId, seed, 1));
        vec3 newDir = normalize(randomNormal + hitValue.normal);
        float roughness = 0.0;
        float metalness = 0.1;
        vec3 newDir2 = normalize(roughness * newDir + reflect(dir, hitValue.normal) * (1 - roughness));
        vec3 hitPos = hitValue.pos;
        vec3 finalColour = vec3(0);
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir2, tmax, 0);
        finalColour += metalness * hitValue.colour;
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, hitPos, tmin, newDir, tmax, 0);
        finalColour += (1 - metalness) * hitValue.colour;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColour, 0.0));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(hitValue.colour, 0.0));
    }*/
}