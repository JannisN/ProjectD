// glslangValidator -V blur.comp -o blur.spv

// todo:
// ein ray pro pixel, und für den auch die normale speichern
// tiefendifferenz der tiefe nach anpassen
// beim rand mehr samples von den anderen seiten holen (vlt auch allgemein mehr),
// man könnte auch an den rändern anders bluren
// mehr zufällige pixelverteilung für AA
// bessere 9x9 blurverteilung statt einfach nur diagonal rutschen
// bei den samples auf deren normals/tiefen achten anstatt sie einfach zu verwerfen -> für schönere ränder
// oder besser die normals der samples speichern
// man könnte bei dem normalentests prüfen ob objekt flat oder smooth geshadet ist, um ecken zu erhalten

#version 460

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

//layout (set = 0, binding = 0) uniform writeonly image2D texelBuffer;
layout (set = 0, binding = 0, rgba8) uniform image2D texelBuffer;
layout (set = 0, binding = 1, rgba8) uniform image2D texelBuffer2;
layout (set = 0, binding = 2, rgba8) uniform image2D normalImage;
layout (set = 0, binding = 3, rgba8) uniform image2D depthImage;

layout (push_constant) uniform mypc_t {
    int time;
} mypc;

const uint blurSize = 3;

float sphereDistr(float x, float y) {
	x = x * 2.0;
	y = y * 2.0;
	float yBackup = y;
	if (y < 0.0) {
		y = 0.0;
	}
	float invX = sqrt(1.0 - x * x);
	float invY = sqrt(1.0 - y * y);
	float res = (1.0 / 3.14159 * (0.5 * (y * invY + asin(invY)) - y * invY - 0.5 * (x * invX + asin(x)) + y * x));
	if (yBackup < 0.0) {
		y = -yBackup;
		res *= 2.0;
		//res += (1.0 / 3.14159 * (0.5 * (y * invY + asin(invY)) - y * invY - 0.5 * (x * invX + asin(x)) + y * x));
		//y = 1.0 - y;
		invY = sqrt(1.0 - y * y);
		res -= (1.0 / 3.14159 * (0.5 * (y * invY + asin(invY)) - y * invY - 0.5 * (x * invX + asin(x)) + y * x));
	}
	return res;
}

vec4 getAverage(float n1X, float n1Y, ivec2 coordsOffset) {
    int windowWidth = imageSize(texelBuffer2).x * 3 / 4;
    int windowHeight = imageSize(texelBuffer2).y;

	vec4 val = vec4(0);
	vec4 normalIm = vec4(imageLoad(normalImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	vec3 normal = (normalIm.xyz - vec3(0.5)) * 2.0;
	vec4 depthIm = vec4(imageLoad(depthImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	float depth = 100 * (depthIm.x + depthIm.y / 255.0 + depthIm.z / 255.0 / 255.0);

	vec4 normalIm2 = vec4(imageLoad(normalImage, coordsOffset + ivec2(n1X, n1Y)));
	vec3 normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
	vec4 depthIm2 = vec4(imageLoad(depthImage, coordsOffset + ivec2(n1X, n1Y)));
	float depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);

	if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.80 && n1X < windowWidth / 9 && n1Y < windowHeight / 9) {
		val = vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y)));
		//val.a = 1.0;
	} else {
		float sampleCount = 0;
		for (int i = 0; i < blurSize; i++) {
			for (int j = 0; j < blurSize; j++) {
				ivec2 newCoords = ivec2(n1X * blurSize + imageSize(texelBuffer).x + i, n1Y * blurSize + j);
				normalIm2 = vec4(imageLoad(normalImage, newCoords));
				normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
				depthIm2 = vec4(imageLoad(depthImage, newCoords));
				depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);
				if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.80 && n1X * blurSize + i < windowWidth / 3 && n1Y * blurSize + j < windowHeight / 3) {
					//sampleCount++;
					vec4 sampleColour = vec4(imageLoad(texelBuffer2, newCoords));
					val += vec4(sampleColour.xyz * sampleColour.a, sampleColour.a);
					sampleCount += sampleColour.a;
				} else {
					//----------------------------------
					vec4 val2 = vec4(0.0);
					int sampleCount2 = 0;
					for (int i2 = 0; i2 < blurSize; i2++) {
						for (int j2 = 0; j2 < blurSize; j2++) {
							ivec2 newCoords2 = ivec2((newCoords.x - imageSize(texelBuffer).x) * blurSize + i2, newCoords.y * blurSize + j2);
							normalIm2 = vec4(imageLoad(normalImage, newCoords2));
							normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
							depthIm2 = vec4(imageLoad(depthImage, newCoords2));
							depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);
							if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.80 && newCoords2.x < windowWidth && newCoords2.y < windowHeight) {
								sampleCount2++;
								val2 += vec4(imageLoad(texelBuffer2, newCoords2));
							}
						}
					}
					if (sampleCount2 != 0) {
						val += vec4(val2.xyz / 255.0, float(sampleCount2) / 255.0);
						sampleCount += float(sampleCount2) / 255.0;
					}
					//----------------------------------
				}
			}
		}
		if (sampleCount > 0.0) {
			val.xyz /= sampleCount;
			//val.a = 1.0;
		}
		else {
			//val.a = 0.0;
			val = vec4(0.0, 0.0, 1.0, 0.0);
		}
		//val = vec4(float(sampleCount) / 9.0);
	}
	return val;
}

void main1() {
	vec4 normalIm = vec4(imageLoad(normalImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	vec3 normal = (normalIm.xyz - vec3(0.5)) * 2.0;
	vec4 depthIm = vec4(imageLoad(depthImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	float depth = 100 * (depthIm.x + depthIm.y / 255.0 + depthIm.z / 255.0 / 255.0);

	vec4 colour = vec4(0);
	int radius = 4;
	int count = 0;
	int length = 2 * radius + 1;
	for (int i = -radius; i <= radius; i++) {
		for (int j = -radius; j <= radius; j++) {
			vec4 normalIm2 = vec4(imageLoad(normalImage, ivec2(int(gl_GlobalInvocationID.x) + i, int(gl_GlobalInvocationID.y) + j)));
			vec3 normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
			vec4 depthIm2 = vec4(imageLoad(depthImage, ivec2(int(gl_GlobalInvocationID.x) + i, int(gl_GlobalInvocationID.y) + j)));
			float depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);
			if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.90) {
				colour += vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x) + i, int(gl_GlobalInvocationID.y) + j)));
				count++;
			}
		}
	}
	colour /= count;
	//colour = vec4(vec3(1.0 * (depthIm.x + depthIm.y / 255.0 + depthIm.z / 255.0 / 255.0)), 0);
	/*if (mypc.time == 0) {
		imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour / 9.0);
	} else {
		imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour / 9.0
		+ imageLoad(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	}*/
	imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour);
	//vec4 colour = vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x) + 600, int(gl_GlobalInvocationID.y))));
}

void main() {
	//vec4 colour = vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	/*const float side = 1;//exp(-1/1);
	const float corner = 1;//exp(-2/1);
	vec4 colour = vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	//colour.x = 1 - colour.x;
	colour += side * (vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x + 1), int(gl_GlobalInvocationID.y))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y + 1))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x - 1), int(gl_GlobalInvocationID.y))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y - 1)))));
	colour += corner * (vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x + 1), int(gl_GlobalInvocationID.y + 1))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x - 1), int(gl_GlobalInvocationID.y + 1))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x + 1), int(gl_GlobalInvocationID.y - 1))))
	+ vec4(imageLoad(texelBuffer2, ivec2(int(gl_GlobalInvocationID.x - 1), int(gl_GlobalInvocationID.y - 1)))));
	colour /= (1.0 + 4.0 * (side + corner));*/

	//int timeOffset = 0;
	int timeOffset = mypc.time - 4;
	
	ivec2 coordsOffset = ivec2(imageSize(texelBuffer).x, imageSize(texelBuffer).y / 3);
	ivec2 coords = coordsOffset + ivec2(int(gl_GlobalInvocationID.x + timeOffset) / 9, int(gl_GlobalInvocationID.y + timeOffset) / 9);

	int offsetX = int(gl_GlobalInvocationID.x + timeOffset) % 9 < 4 ? -1 : 0;
	int n1X = int(gl_GlobalInvocationID.x + timeOffset) / 9 + offsetX;
	float distr1X;
	if (offsetX == -1) {
		distr1X = float(4 - int(gl_GlobalInvocationID.x + timeOffset) % 9) / 9.0;
	} else {
		distr1X = float(9 - (int(gl_GlobalInvocationID.x + timeOffset) % 9 - 4)) / 9.0;
	}
	//distr1X = 1.0 - distr1X;

	int offsetY = int(gl_GlobalInvocationID.y + timeOffset) % 9 < 4 ? -1 : 0;
	int n1Y = int(gl_GlobalInvocationID.y + timeOffset) / 9 + offsetY;
	float distr1Y;
	if (offsetY == -1) {
		distr1Y = float(4 - int(gl_GlobalInvocationID.y + timeOffset) % 9) / 9.0;
	} else {
		distr1Y = float(9 - (int(gl_GlobalInvocationID.y + timeOffset) % 9 - 4)) / 9.0;
	}
	//distr1Y = 1.0 - distr1Y;

	vec4 val00 = vec4(0);
	vec4 val01 = vec4(0);
	vec4 val11 = vec4(0);
	vec4 val10 = vec4(0);
	/*
	vec4 val00 = ((distr1X) * (distr1Y)) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y)));
	vec4 val01 = ((distr1X) * ((1.0 - distr1Y))) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y + 1)));
	vec4 val11 = (((1.0 - distr1X)) * ((1.0 - distr1Y))) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y + 1)));
	vec4 val10 = (((1.0 - distr1X)) * (distr1Y)) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y)));
	*/


	/*{
		vec4 normalIm = vec4(imageLoad(normalImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
		vec3 normal = (normalIm.xyz - vec3(0.5)) * 2.0;
		vec4 depthIm = vec4(imageLoad(depthImage, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
		float depth = 100 * (depthIm.x + depthIm.y / 255.0 + depthIm.z / 255.0 / 255.0);

		vec4 normalIm2 = vec4(imageLoad(normalImage, coordsOffset + ivec2(n1X, n1Y)));
		vec3 normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
		vec4 depthIm2 = vec4(imageLoad(depthImage, coordsOffset + ivec2(n1X, n1Y)));
		float depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);

		if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.90) {
			val00 = vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y)));
		} else {
			int sampleCount = 0;
			for (int i = 0; i < blurSize; i++) {
				for (int j = 0; j < blurSize; j++) {
					ivec2 newCoords = ivec2(n1X * blurSize + imageSize(texelBuffer).x + i, n1Y * blurSize + j);
					vec4 normalIm2 = vec4(imageLoad(normalImage, newCoords));
					vec3 normal2 = (normalIm2.xyz - vec3(0.5)) * 2.0;
					vec4 depthIm2 = vec4(imageLoad(depthImage, newCoords));
					float depth2 = 100 * (depthIm2.x + depthIm2.y / 255.0 + depthIm2.z / 255.0 / 255.0);
					if (abs(depth2 - depth) < 0.2 && dot(normal, normal2) > 0.90) {
						sampleCount++;
						val00 += vec4(imageLoad(texelBuffer2, newCoords));
					}
				}
			}
			val00 /= sampleCount;
		}
	}*/

	val00 = getAverage(n1X, n1Y, coordsOffset);
	val01 = getAverage(n1X, n1Y + 1, coordsOffset);
	val11 = getAverage(n1X + 1, n1Y + 1, coordsOffset);
	val10 = getAverage(n1X + 1, n1Y, coordsOffset);

	float total = 0.0;

	val00.xyz *= ((distr1X) * (distr1Y)) * val00.a;
	total += ((distr1X) * (distr1Y)) * val00.a;

	val01.xyz *= ((distr1X) * ((1.0 - distr1Y))) * val01.a;
	total += ((distr1X) * ((1.0 - distr1Y))) * val01.a;

	val11.xyz *= (((1.0 - distr1X)) * ((1.0 - distr1Y))) * val11.a;
	total += (((1.0 - distr1X)) * ((1.0 - distr1Y))) * val11.a;

	val10.xyz *= (((1.0 - distr1X)) * (distr1Y)) * val10.a;
	total += (((1.0 - distr1X)) * (distr1Y)) * val10.a;
	
	/*if (val00.a > 0.0) {
		val00 *= ((distr1X) * (distr1Y));
		total += ((distr1X) * (distr1Y));
	} else {
		val00 = vec4(0.0);
	}
	if (val01.a > 0.0) {
		val01 *= ((distr1X) * ((1.0 - distr1Y)));
		total += ((distr1X) * ((1.0 - distr1Y)));
	} else {
		val01 = vec4(0.0);
	}
	if (val11.a > 0.0) {
		val11 *= (((1.0 - distr1X)) * ((1.0 - distr1Y)));
		total += (((1.0 - distr1X)) * ((1.0 - distr1Y)));
	} else {
		val11 = vec4(0.0);
	}
	if (val10.a > 0.0) {
		val10 *= (((1.0 - distr1X)) * (distr1Y));
		total += (((1.0 - distr1X)) * (distr1Y));
	} else {
		val10 = vec4(0.0);
	}*/
	

	vec4 colour = (val00 + val01 + val11 + val10) / total;
	//colour = vec4(distr1X);
	//vec4 colour = vec4(val00.a + val01.a + val11.a + val10.a);

	//colour = vec4(imageLoad(texelBuffer2, coords));

	/*float total = (distr1X * distr1X) + (distr1Y * distr1Y);
	total += (distr1X * distr1X) + ((1.0 - distr1Y) * (1.0 - distr1Y));
	total += ((1.0 - distr1X) * (1.0 - distr1X)) + ((1.0 - distr1Y) * (1.0 - distr1Y));
	total += ((1.0 - distr1X) * (1.0 - distr1X)) + (distr1Y * distr1Y);

	vec4 val00 = ((distr1X * distr1X) + (distr1Y * distr1Y)) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y)));
	vec4 val01 = ((distr1X * distr1X) + ((1.0 - distr1Y) * (1.0 - distr1Y))) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y + 1)));
	vec4 val11 = (((1.0 - distr1X) * (1.0 - distr1X)) + ((1.0 - distr1Y) * (1.0 - distr1Y))) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y + 1)));
	vec4 val10 = (((1.0 - distr1X) * (1.0 - distr1X)) + (distr1Y * distr1Y)) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y)));

	vec4 colour = (val00 + val01 + val11 + val10) / total;*/
	

	/*vec4 val00 = sphereDistr(1.0 - distr1X - 0.5, 1.0 - distr1Y - 0.5) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y)));
	vec4 val01 = sphereDistr(1.0 - distr1X - 0.5, distr1Y - 0.5) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X, n1Y + 1)));
	vec4 val11 = sphereDistr(distr1X - 0.5, distr1Y - 0.5) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y + 1)));
	vec4 val10 = sphereDistr(distr1X - 0.5, 1.0 - distr1Y - 0.5) * vec4(imageLoad(texelBuffer2, coordsOffset + ivec2(n1X + 1, n1Y)));
	vec4 colour = val10 + val00 + val11 + val01;*/
	if (mypc.time == 0) {
		imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour / 9.0);
	} else {
		imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour / 9.0
		+ imageLoad(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y))));
	}
	//imageStore(texelBuffer, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), colour);
}